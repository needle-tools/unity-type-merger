using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using UnityAnalyzers;

namespace Needle.ClassMerging.Core
{
	public class ClassWriter
	{
		private readonly CodeWriter debug;

		public ClassWriter(CodeWriter debug)
		{
			this.debug = debug;
		}

		public void CollectInfos(GeneratorExecutionContext context, IEnumerable<ClassMergeInfo> infos)
		{
			foreach (var info in infos)
			{
				var found = false;
				foreach (var tree in context.Compilation.SyntaxTrees)
				{
					if (found) break;
					// If we found the class we dont need to continue
					var root = tree.GetCompilationUnitRoot();
					var visitor = new ClassInfoWalker(info, debug);
					visitor.Visit(root);
					found = visitor.Result;
				}

				const bool searchInAssemblies = false;
				if (!found && searchInAssemblies)
				{
					debug.WriteLine();
					debug.WriteLine("SEARCHING IN REFERENCED ASSEMBLIES ...");
					// search in referenced assemblies
					// search in reverse order since it's more likely that we want to merge a type from our own project
					// which is in the end of the list
					for (var index = context.Compilation.References.ToArray().Length - 1; index >= 0; index--)
					{
						var assembly = context.Compilation.References.ToArray()[index];
						if (found) break;
						var assemblySymbol = context.Compilation.GetAssemblyOrModuleSymbol(assembly) as IAssemblySymbol;
						if (assemblySymbol == null)
						{
							continue;
						}
						var types = assemblySymbol.GetForwardedTypes();
						debug.WriteLine(
							$"SEARCHING IN ASSEMBLY: {assembly.Display} ... Modules: {assemblySymbol.Modules.Count()}, Types: {types.Length} ...");
						foreach (var moduleSymbol in assemblySymbol.Modules)
						{
							if (found) break;
							debug.WriteLine(
								$"SEARCHING IN MODULE: {moduleSymbol.Name} ({moduleSymbol.DeclaringSyntaxReferences.Count()}) ...");
							foreach (var tree in moduleSymbol.DeclaringSyntaxReferences)
							{
								if (found) break;
								var root = tree.GetSyntax();
								debug.WriteLine("SEARCHING IN TREE: " + tree.SyntaxTree.FilePath + " ...");
								var visitor = new ClassInfoWalker(info, debug);
								visitor.Visit(root);
								found = visitor.Result;
								// For testing only check one
								return;
							}
							// For testing only check one
							break;
						}
						// For testing only check one
						break;
					}
				}
			}
		}

		public IEnumerable<string> WriteInfos(GeneratorExecutionContext context,
			IEnumerable<ClassMergeInfo> infos,
			CodeWriter writer)
		{
			writer.WriteLine("// Generated by Needle Class Merger at " +
			                 DateTime.Now.ToString(CultureInfo.InvariantCulture) + "\n");

			var infosByTarget = infos.GroupBy(i => i.TargetClassName).ToDictionary(g => g.Key, g => g.ToList());

			foreach (var info in infosByTarget)
			{
				var data = info.Value;

				var targetClassInfo = data.FirstOrDefault();
				if (targetClassInfo == null) continue;

				var imported = new HashSet<string>();
				foreach (var entry in data)
				{
					foreach (var i in entry.imports)
					{
						var importString = i.ToString();
						if (imported.Contains(importString)) continue;
						imported.Add(importString);
						writer.WriteLine(importString);
					}
				}

				writer.WriteLine();

				var hasNamespace = !string.IsNullOrEmpty(targetClassInfo.TargetClassNamespace);
				if (hasNamespace)
				{
					writer.WriteLine("namespace " + targetClassInfo.TargetClassNamespace);
					writer.BeginBlock(); // Begin Namespace
				}

				var classDeclarationStr = $"public partial class {targetClassInfo.TargetClassName}";
				AddBaseTypes(context, data, ref classDeclarationStr);

				writer.WriteLine(classDeclarationStr);
				writer.BeginBlock(); // Begin Class
				foreach (var entry in data)
				{
					foreach (var c in entry.classes)
					{
						var className = c.Identifier.Text;
						writer.WriteLine("// Begin " + className);
						foreach (var mem in c.Members)
						{
							writer.WriteLine(mem.ToString());
						}
						writer.WriteLine("// End " + className + "\n");
					}
				}
				writer.EndBlock(); // End Class

				if (hasNamespace)
					writer.EndBlock(); // End Namespace

				yield return info.Key;
			}
		}

		private void AddBaseTypes(GeneratorExecutionContext context,
			IEnumerable<ClassMergeInfo> infos,
			ref string str)
		{
			var classes = infos.SelectMany(i => i.classes).ToList();
			var foundInterfaces = new HashSet<string>();
			var foundClasses = new HashSet<string>();
			foreach (var cl in classes)
			{
				foreach (var baseType in cl.BaseList?.Types ?? Enumerable.Empty<BaseTypeSyntax>())
				{
					var type = baseType.Type.ToString();

					if (foundInterfaces.Contains(type)) continue;
					if (foundClasses.Contains(type)) continue;

					if (baseType.Type is IdentifierNameSyntax id)
					{
						var symbol = context.Compilation.GetSemanticModel(id.SyntaxTree).GetSymbolInfo(id).Symbol;
						// check if its an interface
						if (symbol is ITypeSymbol typeSymbol && typeSymbol.TypeKind == TypeKind.Interface)
							foundInterfaces.Add(type);
						// or a class
						else if (symbol is INamedTypeSymbol namedTypeSymbol &&
						         namedTypeSymbol.TypeKind == TypeKind.Class)
							foundClasses.Add(type);
					}
				}
			}
			var classString = foundClasses.FirstOrDefault();
			var interfacesString = string.Join(", ", foundInterfaces);
			if (!string.IsNullOrEmpty(classString) || !string.IsNullOrEmpty(interfacesString))
			{
				str += " : ";
				if (!string.IsNullOrEmpty(classString)) str += classString;
				if (!string.IsNullOrEmpty(interfacesString))
				{
					if (!string.IsNullOrEmpty(classString)) str += ", ";
					str += interfacesString;
				}

				for (var i = 1; i < foundClasses.Count; i++)
				{
					str += " // " + foundClasses.ElementAt(i);
				}
			}
		}
	}
}