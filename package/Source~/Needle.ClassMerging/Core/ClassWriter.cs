using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Editing;
using Microsoft.CodeAnalysis.VisualBasic.Syntax;
using Needle.ClassMerging.Utils;
using IdentifierNameSyntax = Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax;
using VisualBasicExtensions = Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions;

namespace Needle.ClassMerging.Core
{
	public class ClassWriter
	{
		private readonly CodeWriter debug;

		public ClassWriter(CodeWriter debug)
		{
			this.debug = debug;
		}

		public void CollectInfos(GeneratorExecutionContext context, IEnumerable<ClassMergeInfo> infos)
		{
			var syntaxTreeUtil = new SyntaxTreeUtil(context);

			foreach (var info in infos)
			{
				var found = false;

				foreach (var tree in context.Compilation.SyntaxTrees)
				{
					if (found) break;
					var model = context.Compilation.GetSemanticModel(tree);

					// If we dont have a full name yet but a typeof syntax, try to get the full name
					if (string.IsNullOrEmpty(info.SourceClassFullName) && info.SourceTypeSyntax != null)
					{
						if (info.SourceTypeSyntax.SyntaxTree == tree)
						{
							var typeInfo = model.GetTypeInfo(info.SourceTypeSyntax);
							if (typeInfo.Type != null)
							{
								info.SourceClassFullName = typeInfo.Type.ToDisplayString();
							}
						}
					}

					if (!string.IsNullOrEmpty(info.SourceClassFullName))
					{
						// If we found the class we dont need to continue
						var root = tree.GetCompilationUnitRoot();
						var visitor = new ClassInfoWalker(info, debug);
						visitor.Visit(root);
						found = visitor.Result;
					}

				}

				if (!found && info.SourceTypeSyntax != null)
				{
					var name = info.SourceTypeSyntax.TryGetInferredMemberName();
					if (name != null)
					{
						var tree = syntaxTreeUtil.TryFindTree(name);
						if (tree != null)
						{
							var root = tree.GetCompilationUnitRoot();
							var visitor = new ClassInfoWalker(info, debug);
							visitor.Visit(root);
							found = visitor.Result;
						}
					}
				}

				// if (!found && !string.IsNullOrWhiteSpace(info.SourceClassFullName))
				// {
				// 	var typeSymbol = context.Compilation.GetTypeByMetadataName(info.SourceClassFullName!);
				// 	debug.WriteLine("SEARCH:\t" + info.SourceClassFullName + " is " + typeSymbol + "?");
				// 	if (typeSymbol != null)
				// 	{
				// 		var references = typeSymbol.DeclaringSyntaxReferences;
				// 		foreach (var reference in references)
				// 		{
				// 			if (found) break;
				// 			var tree = reference.SyntaxTree;
				// 			var root = tree.GetCompilationUnitRoot();
				// 			var visitor = new ClassInfoWalker(info, debug);
				// 			visitor.Visit(root);
				// 			found = visitor.Result;
				// 		}
				// 	}
				// }

				const bool searchInAssemblies = false;
				if (!found && searchInAssemblies)
				{
					debug.WriteLine();
					debug.WriteLine("SEARCHING IN REFERENCED ASSEMBLIES ...");
					// search in referenced assemblies
					// search in reverse order since it's more likely that we want to merge a type from our own project
					// which is in the end of the list
					for (var index = context.Compilation.References.ToArray().Length - 1; index >= 0; index--)
					{
						var assembly = context.Compilation.References.ToArray()[index];
						if (found) break;
						var assemblySymbol = context.Compilation.GetAssemblyOrModuleSymbol(assembly) as IAssemblySymbol;
						if (assemblySymbol == null)
						{
							continue;
						}
						var types = assemblySymbol.GetForwardedTypes();
						debug.WriteLine(
							$"SEARCHING IN ASSEMBLY: {assembly.Display} ... Modules: {assemblySymbol.Modules.Count()}, Types: {types.Length} ...");
						foreach (var moduleSymbol in assemblySymbol.Modules)
						{
							if (found) break;
							debug.WriteLine(
								$"SEARCHING IN MODULE: {moduleSymbol.Name} ({moduleSymbol.DeclaringSyntaxReferences.Count()}) ...");
							foreach (var tree in moduleSymbol.DeclaringSyntaxReferences)
							{
								if (found) break;
								var root = tree.GetSyntax();
								debug.WriteLine("SEARCHING IN TREE: " + tree.SyntaxTree.FilePath + " ...");
								var visitor = new ClassInfoWalker(info, debug);
								visitor.Visit(root);
								found = visitor.Result;
								// For testing only check one
								return;
							}
						}
					}
				}
			}
		}

		public IEnumerable<string> WriteInfos(GeneratorExecutionContext context,
			IEnumerable<ClassMergeInfo> infos,
			CodeWriter writer)
		{
			writer.WriteLine("// Generated by Needle Class Merger at " +
			                 DateTime.Now.ToString(CultureInfo.InvariantCulture));

			var currentAssemblyName = context.Compilation.AssemblyName;
			writer.WriteLine($"// Assembly: {currentAssemblyName}");
			writer.WriteLine();

			var infosByTarget = infos.GroupBy(i => i.TargetClassName).ToDictionary(g => g.Key, g => g.ToList());

			foreach (var info in infosByTarget)
			{
				var data = info.Value;

				var targetClassInfo = data.FirstOrDefault();
				if (targetClassInfo == null) continue;

				var imported = new HashSet<string>();
				foreach (var entry in data)
				{
					foreach (var i in entry.imports)
					{
						var importString = i.ToString();
						if (imported.Contains(importString)) continue;
						imported.Add(importString);
						// if(importString.Contains("Collections.Generic"))
						writer.WriteLine(importString);
					}
				}

				writer.WriteLine();

				var hasNamespace = !string.IsNullOrEmpty(targetClassInfo.TargetClassNamespace);
				if (hasNamespace)
				{
					writer.WriteLine("namespace " + targetClassInfo.TargetClassNamespace);
					writer.BeginBlock(); // Begin Namespace
				}

				var classDeclarationStr = $"public partial class {targetClassInfo.TargetClassName}";
				try
				{
					AddBaseTypes(context, data, ref classDeclarationStr);
				}
				catch (Exception ex)
				{
					context.LogError(ex.Message);
				}

				writer.WriteLine(classDeclarationStr);
				writer.BeginBlock(); // Begin Class
				foreach (var entry in data)
				{
					foreach (var c in entry.classes)
					{
						var className = c.Identifier.Text;
						writer.WriteLine("// Begin " + className);
						foreach (var mem in c.Members)
						{
							writer.WriteLine(mem.ToString());
						}
						writer.WriteLine("// End " + className + "\n");
					}
				}
				writer.EndBlock(); // End Class

				if (hasNamespace)
					writer.EndBlock(); // End Namespace

				yield return info.Key;
			}
		}

		private void AddBaseTypes(GeneratorExecutionContext context,
			IEnumerable<ClassMergeInfo> infos,
			ref string str)
		{
			// TODO: check if the target class already has a base type

			var classes = infos.SelectMany(i => i.classes).ToList();
			var foundInterfaces = new HashSet<string>();
			var foundClasses = new HashSet<string>();
			foreach (var cl in classes)
			{
				foreach (var baseType in cl.BaseList?.Types ?? Enumerable.Empty<BaseTypeSyntax>())
				{
					var type = baseType.Type.ToString();

					if (foundInterfaces.Contains(type)) continue;
					if (foundClasses.Contains(type)) continue;

					if (baseType.Type is IdentifierNameSyntax id)
					{
						var symbol = context.Compilation.GetSemanticModel(id.SyntaxTree).GetSymbolInfo(id).Symbol;
						// check if its an interface
						if (symbol is ITypeSymbol typeSymbol && typeSymbol.TypeKind == TypeKind.Interface)
							foundInterfaces.Add(type);
						// or a class
						else if (symbol is INamedTypeSymbol namedTypeSymbol &&
						         namedTypeSymbol.TypeKind == TypeKind.Class)
							foundClasses.Add(type);
					}
				}
			}

			var classString = foundClasses.FirstOrDefault();
			var interfacesString = string.Join(", ", foundInterfaces);
			if (!string.IsNullOrEmpty(classString) || !string.IsNullOrEmpty(interfacesString))
			{
				str += " : ";
				if (!string.IsNullOrEmpty(classString)) str += classString;
				if (!string.IsNullOrEmpty(interfacesString))
				{
					if (!string.IsNullOrEmpty(classString)) str += ", ";
					str += interfacesString;
				}

				for (var i = 1; i < foundClasses.Count; i++)
				{
					str += " // " + foundClasses.ElementAt(i);
				}
			}
		}
	}
}