using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using UnityAnalyzers;

namespace Needle.ClassMerging.Core
{
	public class ClassWriter
	{
		private readonly CodeWriter debug;

		public ClassWriter(CodeWriter debug)
		{
			this.debug = debug;
		}

		public void CollectInfos(GeneratorExecutionContext context, IEnumerable<ClassMergeInfo> infos)
		{
			foreach (var info in infos)
			{
				foreach (var tree in context.Compilation.SyntaxTrees)
				{
					// If we found the class we dont need to continue
					var root = tree.GetCompilationUnitRoot();
					var visitor = new ClassInfoWalker(info, debug);
					visitor.Visit(root);
					if (visitor.Result) break;
				}
			}
		}

		public IEnumerable<string> WriteInfos(GeneratorExecutionContext context,
			IEnumerable<ClassMergeInfo> infos,
			CodeWriter writer)
		{
			writer.WriteLine("// Generated by Needle Class Merger at " +
			                 DateTime.Now.ToString(CultureInfo.InvariantCulture) + "\n");

			var infosByTarget = infos.GroupBy(i => i.TargetClassName).ToDictionary(g => g.Key, g => g.ToList());

			foreach (var info in infosByTarget)
			{
				var data = info.Value;

				var targetClassInfo = data.FirstOrDefault();
				if (targetClassInfo == null) continue;

				var imported = new HashSet<string>();
				foreach (var entry in data)
				{
					foreach (var i in entry.imports)
					{
						var importString = i.ToString();
						if (imported.Contains(importString)) continue;
						imported.Add(importString);
						writer.WriteLine(importString);
					}
				}

				writer.WriteLine();

				var hasNamespace = !string.IsNullOrEmpty(targetClassInfo.TargetClassNamespace);
				if (hasNamespace)
				{
					writer.WriteLine("namespace " + targetClassInfo.TargetClassNamespace);
					writer.BeginBlock(); // Begin Namespace
				}

				var classDeclarationStr = $"public partial class {targetClassInfo.TargetClassName}";
				AddBaseTypes(context, data, ref classDeclarationStr);

				writer.WriteLine(classDeclarationStr);
				writer.BeginBlock(); // Begin Class
				foreach (var entry in data)
				{
					foreach (var c in entry.classes)
					{
						var className = c.Identifier.Text;
						writer.WriteLine("// Begin " + className);
						foreach (var mem in c.Members)
						{
							writer.WriteLine(mem.ToString());
						}
						writer.WriteLine("// End " + className + "\n");
					}
				}
				writer.EndBlock(); // End Class

				if (hasNamespace)
					writer.EndBlock(); // End Namespace

				yield return info.Key;
			}
		}

		private void AddBaseTypes(GeneratorExecutionContext context,
			IEnumerable<ClassMergeInfo> infos,
			ref string str)
		{
			var classes = infos.SelectMany(i => i.classes).ToList();
			var foundInterfaces = new HashSet<string>();
			var foundClasses = new HashSet<string>();
			foreach (var cl in classes)
			{
				foreach (var baseType in cl.BaseList?.Types ?? Enumerable.Empty<BaseTypeSyntax>())
				{
					var type = baseType.Type.ToString();

					if (foundInterfaces.Contains(type)) continue;
					if (foundClasses.Contains(type)) continue;

					if (baseType.Type is IdentifierNameSyntax id)
					{
						var symbol = context.Compilation.GetSemanticModel(id.SyntaxTree).GetSymbolInfo(id).Symbol;
						// check if its an interface
						if (symbol is ITypeSymbol typeSymbol && typeSymbol.TypeKind == TypeKind.Interface)
							foundInterfaces.Add(type);
						// or a class
						else if (symbol is INamedTypeSymbol namedTypeSymbol &&
						         namedTypeSymbol.TypeKind == TypeKind.Class)
							foundClasses.Add(type);
					}
				}
			}
			var classString = foundClasses.FirstOrDefault();
			var interfacesString = string.Join(", ", foundInterfaces);
			if (!string.IsNullOrEmpty(classString) || !string.IsNullOrEmpty(interfacesString))
			{
				str += " : ";
				if (!string.IsNullOrEmpty(classString)) str += classString;
				if (!string.IsNullOrEmpty(interfacesString))
				{
					if (!string.IsNullOrEmpty(classString)) str += ", ";
					str += interfacesString;
				}

				for (var i = 1; i < foundClasses.Count; i++)
				{
					str += " // " + foundClasses.ElementAt(i);
				}
			}
		}
	}
}